package com.swirlds.streamloader.pinot;
//
//import com.fasterxml.jackson.databind.ObjectMapper;
//import org.apache.commons.collections.functors.InstantiateFactory;
//import org.apache.pinot.plugin.segmentwriter.filebased.FileBasedSegmentWriter;
//import org.apache.pinot.segment.local.segment.creator.impl.SegmentColumnarIndexCreator;
//import org.apache.pinot.segment.spi.creator.ColumnIndexCreationInfo;
//import org.apache.pinot.segment.spi.creator.SegmentCreator;
//import org.apache.pinot.segment.spi.creator.SegmentGeneratorConfig;
//import org.apache.pinot.segment.spi.index.creator.SegmentIndexCreationInfo;
//import org.apache.pinot.spi.config.table.TableConfig;
//import org.apache.pinot.spi.data.Schema;
//import org.apache.pinot.spi.data.readers.GenericRow;
//import org.apache.pinot.spi.ingestion.batch.BatchConfigProperties;
//import org.apache.pinot.spi.ingestion.segment.writer.SegmentWriter;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Instant;
import java.util.HashMap;
import java.util.Map;

public class SegmentMaker {
//	public static void main(String[] args) throws Exception {
//		Path outputPath = Path.of("build/SEGMENTS");
//		if (Files.exists(outputPath)) {
//			Files.list(outputPath).forEach(file -> {
//				try {
//					Files.delete(file);
//				} catch (IOException e) {
//					throw new RuntimeException(e);
//				}
//			});
//			Files.delete(outputPath);
//		}
//
//
//		TableConfig tableConfig = new ObjectMapper()
//				.readerFor(TableConfig.class)
//				.readValue(BALANCES_TABLE_CONFIG);
//		Schema schema = Schema.fromString(BALANCES_SCHEMA);
//
//		final Map<String,String> batchConfigOverride = new HashMap<>();
//		batchConfigOverride.put(BatchConfigProperties.OUTPUT_DIR_URI,outputPath.toUri().toString());
//		batchConfigOverride.put(BatchConfigProperties.OVERWRITE_OUTPUT,outputPath.toUri().toString());
//
//		try (SegmentWriter segmentWriter = new FileBasedSegmentWriter()) {
//
//			segmentWriter.init(tableConfig,schema,batchConfigOverride);
//
//			for (int i = 0; i < 5; i++) {
//				segmentWriter.collect(createTestRow(i));
//			}
//			segmentWriter.flush();
//
//
//		}
//	}
//
//	public static GenericRow createTestRow(int i) {
//		final GenericRow row = new GenericRow();
//		row.putValue("account_id","0.0."+i);
//		row.putValue("token_id","0");
//		row.putValue("balance",i*1_000_000L);
//		row.putValue("consensus_timestamp",System.nanoTime());
//		return row;
//	}

	public static final String BALANCES_SCHEMA = """
			{
			  "schemaName": "balance",
			  "dimensionFieldSpecs": [
			    {
			      "name": "account_id",
			      "dataType": "STRING"
			    },
			    {
			      "name": "token_id",
			      "dataType": "STRING"
			    },
			    {
			      "name": "balance",
			      "dataType": "LONG"
			    }
			  ],
			  "dateTimeFieldSpecs": [
			    {
			      "name": "consensus_timestamp",
			      "dataType": "LONG",
			      "format": "1:NANOSECONDS:EPOCH",
			      "granularity": "1:NANOSECONDS"
			    }
			  ]
			}""";
	public static final String BALANCES_TABLE_CONFIG = """
			{
				"tableName": "balance_OFFLINE",
				"tableType": "OFFLINE",
				"segmentsConfig": {
				  "timeType": "NANOSECONDS",
				  "schemaName": "balance",
				  "replication": "1",
				  "timeColumnName": "consensus_timestamp"
				},
				"tenants": {
				  "broker": "DefaultTenant",
				  "server": "DefaultTenant"
				},
				"tableIndexConfig": {
				  "autoGeneratedInvertedIndex": false,
				  "createInvertedIndexDuringSegmentGeneration": false,
				  "enableDefaultStarTree": false,
				  "aggregateMetrics": false,
				  "rangeIndexVersion": 2,
				  "enableDynamicStarTreeCreation": false,
				  "nullHandlingEnabled": false
				},
				"metadata": {},
				"isDimTable": false
		    }""";
}

/*

//		try (SegmentCreator segmentCreator = new SegmentColumnarIndexCreator()) {
		try (SegmentWriter segmentWriter = new FileBasedSegmentWriter()) {
			SegmentGeneratorConfig config = new SegmentGeneratorConfig(tableConfig, schema);
			SegmentIndexCreationInfo indexCreationInfo = new SegmentIndexCreationInfo();
			Map<String, ColumnIndexCreationInfo> indexCreationInfoMap = new HashMap<>();

			segmentWriter.

			segmentWriter.init(config, indexCreationInfo,
					indexCreationInfoMap, schema, outputPath.toFile());
			segmentWriter.setSegmentName("balances-"+ Instant.now());

			for (int i = 0; i < 5; i++) {
				segmentWriter.indexRow(createTestRow(i));
			}
			segmentWriter.seal();


			System.out.println("indexCreationInfo = " + indexCreationInfo);
			System.out.println("indexCreationInfo.getTotalDocs() = " + indexCreationInfo.getTotalDocs());
			System.out.println("indexCreationInfoMap.size() = " + indexCreationInfoMap.size());
			for(var entry: indexCreationInfoMap.entrySet()) {
				System.out.println("     " + entry.getKey()+" = " + entry.getValue());
			}
		}
	}
 */